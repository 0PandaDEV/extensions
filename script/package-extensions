#!/usr/bin/env node

import { PutObjectCommand, S3 } from "@aws-sdk/client-s3";
import fs from "node:fs/promises";
import { execFile } from "node:child_process";
import path from "node:path";
import toml from "toml";

const { S3_ACCESS_KEY, S3_SECRET_KEY, S3_BUCKET, SHOULD_PUBLISH } = process.env;

/**
 * Whether we're running offline.
 *
 * The `--offline` flag can be used to suppress interactions with S3, which allows
 * developing the script locally without a set of credentials.
 *
 * Note that this will cause all extensions to be packaged.
 */
const isOffline = process.argv.includes("--offline");

/** Whether packages should be published to the blob store. */
const shouldPublish = SHOULD_PUBLISH === "true" && !isOffline;

const treeSitterPath = path.join(
  process.cwd(),
  "node_modules",
  ".bin",
  "tree-sitter",
);

const s3 = new S3({
  forcePathStyle: false,
  endpoint: "https://nyc3.digitaloceanspaces.com",
  region: "nyc3",
  credentials: {
    accessKeyId: S3_ACCESS_KEY,
    secretAccessKey: S3_SECRET_KEY,
  },
});

const EXTENSIONS_PREFIX = "extensions";

const publishedVersionsByExtensionName = isOffline
  ? {}
  : await getPublishedVersionsByExtensionId();

// Get the list of extension versions in the repository.
const extensionsToml = toml.parse(await fs.readFile("extensions.toml"));

// Package each extension in the repository that has not already
// been packaged.
await fs.mkdir("build", { recursive: true });
try {
  for (const [extensionId, extensionInfo] of Object.entries(extensionsToml)) {
    const publishedVersions =
      publishedVersionsByExtensionName[extensionId] ?? [];

    if (!publishedVersions.includes(extensionInfo.version)) {
      console.log(
        `Packaging '${extensionId}'. Version: ${extensionInfo.version}`,
      );

      await packageExtension(
        extensionId,
        extensionInfo.path,
        extensionInfo.version,
        shouldPublish,
      );
    }
  }
} finally {
  await fs.rm("build", { recursive: true });
}

async function packageExtension(
  extensionId,
  extensionPath,
  extensionVersion,
  shouldPublish,
) {
  const metadata = JSON.parse(
    await fs.readFile(path.join(extensionPath, "extension.json"), "utf-8"),
  );

  if (metadata.version !== extensionVersion) {
    throw new Error(
      [
        `Incorrect version for extension ${extensionId} (${metadata.name})`,
        "",
        `Expected version: ${extensionVersion}`,
        `Actual version: ${metadata.version}`,
      ].join("\n"),
    );
  }

  const packageManifest = {
    name: metadata.name,
    version: metadata.version,
    authors: metadata.authors,
    repository: metadata.repository,
  };

  const packageDir = await fs.mkdtemp(
    path.join("build", extensionId + ".extension"),
  );
  const archiveName = path.join(
    "build",
    `${extensionId}-${packageManifest.version}.tar.gz`,
  );
  const grammarRepoPaths = {};

  const grammarsSrcDir = path.join(extensionPath, "grammars");
  const languagesSrcDir = path.join(extensionPath, "languages");
  const themesSrcDir = path.join(extensionPath, "themes");

  const grammarsPkgDir = path.join(packageDir, "grammars");
  const languagesPkgDir = path.join(packageDir, "languages");
  const themesPkgDir = path.join(packageDir, "themes");

  if (await isDirectory(themesSrcDir)) {
    await fs.mkdir(themesPkgDir);
    packageManifest.themes = {};

    for (const themeFilename of await fs.readdir(themesSrcDir)) {
      const themeFullPath = path.join(themesSrcDir, themeFilename);
      const theme = JSON.parse(await fs.readFile(themeFullPath, "utf-8"));

      validateTheme(theme);

      const themeDestinationPath = path.join(themesPkgDir, themeFilename);
      await fs.copyFile(themeFullPath, themeDestinationPath);
      packageManifest.themes[theme.name] = `themes/${themeFilename}`;
    }
  }

  if (await isDirectory(languagesSrcDir)) {
    await fs.mkdir(languagesPkgDir);
    packageManifest.languages = {};

    for (const languageDirname of await fs.readdir(languagesSrcDir)) {
      const languageFullPath = path.join(languagesSrcDir, languageDirname);
      const config = toml.parse(
        await fs.readFile(path.join(languageFullPath, "config.toml"), "utf-8"),
      );

      validateLanguageConfig(config);

      const languageDestinationPath = path.join(
        languagesPkgDir,
        languageDirname,
      );
      await fs.cp(languageFullPath, languageDestinationPath, {
        recursive: true,
      });
      packageManifest.languages[config.name] = `languages/${languageDirname}`;
    }
  }

  if (await isDirectory(grammarsSrcDir)) {
    await fs.mkdir(grammarsPkgDir);
    packageManifest.grammars = {};

    for (const grammarFilename of await fs.readdir(grammarsSrcDir)) {
      const grammarConfigPath = path.join(grammarsSrcDir, grammarFilename);
      const config = toml.parse(await fs.readFile(grammarConfigPath, "utf-8"));

      const grammarName = grammarFilename.replace(/\.toml$/, "");
      const grammarRepoKey = `${config.repository}/${config.commit}`;
      let grammarRepoPath;
      if (grammarRepoPaths[grammarRepoKey]) {
        grammarRepoPath = grammarRepoPaths[grammarRepoKey];
      } else {
        grammarRepoPath = await checkoutGitRepo(
          grammarName,
          config.repository,
          config.commit,
        );
        grammarRepoPaths[grammarRepoKey] = grammarRepoPath;
      }

      const grammarFullPath = config.path
        ? path.join(grammarRepoPath, path)
        : grammarRepoPath;

      await exec(treeSitterPath, ["build-wasm"], {
        cwd: grammarFullPath,
      });

      const wasmSourcePath = path.join(
        grammarRepoPath,
        `tree-sitter-${grammarName}.wasm`,
      );

      const wasmDestinationPath = path.join(
        grammarsPkgDir,
        `${grammarName}.wasm`,
      );
      await fs.copyFile(wasmSourcePath, wasmDestinationPath);
      packageManifest.grammars[grammarName] = `grammars/${grammarName}.wasm`;
    }
  }

  await fs.writeFile(
    path.join(packageDir, "extension.json"),
    JSON.stringify(packageManifest, null, 2),
  );

  const tarOutput = await exec("tar", [
    "-czvf",
    archiveName,
    "-C",
    packageDir,
    ".",
  ]);
  console.log(tarOutput.stderr);

  if (shouldPublish) {
    console.log(`Uploading ${extensionId} version ${extensionVersion}`);
    const archiveData = await fs.readFile(archiveName);

    await s3.send(
      new PutObjectCommand({
        Bucket: S3_BUCKET,
        Key: `${EXTENSIONS_PREFIX}/${extensionId}/${packageManifest.version}/archive.tar.gz`,
        Body: archiveData,
      }),
    );

    await s3.send(
      new PutObjectCommand({
        Bucket: S3_BUCKET,
        Key: `${EXTENSIONS_PREFIX}/${extensionId}/${packageManifest.version}/manifest.json`,
        Body: JSON.stringify(packageManifest),
      }),
    );
  }
}

async function isDirectory(path) {
  try {
    const stats = await fs.stat(path);
    return stats.isDirectory();
  } catch {
    return false;
  }
}

async function getPublishedVersionsByExtensionId() {
  const bucketList = await s3.listObjects({
    Bucket: S3_BUCKET,
    Prefix: `${EXTENSIONS_PREFIX}/`,
  });

  const publishedVersionsByExtensionId = {};
  bucketList.Contents?.forEach((object) => {
    const [_prefix, extensionId, version, _filename] = object.Key.split("/");
    if (!publishedVersionsByExtensionId[extensionId]) {
      publishedVersionsByExtensionId[extensionId] = [];
    }
    publishedVersionsByExtensionId[extensionId].push(version);
  });

  return publishedVersionsByExtensionId;
}

async function checkoutGitRepo(name, repositoryUrl, commitSha) {
  const repoPath = await fs.mkdtemp(
    path.join("build", `${name}-${commitSha}.repo`),
  );
  const processOptions = {
    cwd: repoPath,
  };

  await exec("git", ["init"], processOptions);
  await exec("git", ["remote", "add", "origin", repositoryUrl], processOptions);
  await exec(
    "git",
    ["fetch", "--depth", "1", "origin", commitSha],
    processOptions,
  );
  await exec("git", ["checkout", commitSha], processOptions);
  return repoPath;
}

function exec(command, args, options) {
  return new Promise((resolve, reject) => {
    execFile(command, args, options, (err, stdout, stderr) => {
      if (err) {
        reject(err);
      } else {
        resolve({
          stdout: stdout.toString("utf8"),
          stderr: stderr.toString("utf8"),
        });
      }
    });
  });
}

function validateLanguageConfig(config) {
  //
}

function validateTheme(theme) {
  //
}
